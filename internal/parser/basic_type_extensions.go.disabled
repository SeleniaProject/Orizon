// BasicType extensions to implement DependentType interface
// This file extends BasicType to work with the dependent type system

package parser

// ====== BasicType DependentType Implementation ======

// GetDependency returns nil for basic types (they don't depend on values)
func (bt *BasicType) GetDependency() Expression {
	return nil
}

// Substitute returns the basic type unchanged (no substitution needed)
func (bt *BasicType) Substitute(variable string, value Expression) *DependentType {
	return &DependentType{
		Span:       bt.Span,
		BaseType:   bt,
		Constraint: nil, // No constraint for basic types
	}
}

// IsRefined returns false for basic types (they are not refined)
func (bt *BasicType) IsRefined() bool {
	return false
}

// GetConstraints returns empty constraints for basic types
func (bt *BasicType) GetConstraints() []TypeConstraint {
	return []TypeConstraint{}
}

// SetConstraints does nothing for basic types (they have no constraints)
func (bt *BasicType) SetConstraints(constraints []TypeConstraint) {
	// Basic types don't have constraints to set
}

// Implements dependent type interface for basic types
func (bt *BasicType) IsDependentType() bool {
	return false
}

// GetDependencies returns empty since basic types have no dependencies
func (bt *BasicType) GetDependencies() []string {
	return []string{}
}

// Unify attempts to unify with another dependent type
func (bt *BasicType) Unify(other DependentType) ([]TypeConstraint, bool) {
	if otherBasic, ok := other.(*BasicType); ok {
		if bt.Name == otherBasic.Name {
			return []TypeConstraint{}, true
		}
	}
	return nil, false
}

// IsEquivalent checks if this basic type is equivalent to another
func (bt *BasicType) IsEquivalent(other DependentType) bool {
	if otherBasic, ok := other.(*BasicType); ok {
		return bt.Name == otherBasic.Name
	}
	return false
}

// ValidateConstraints always returns true for basic types (no constraints to validate)
func (bt *BasicType) ValidateConstraints() (bool, []string) {
	return true, []string{}
}

// ====== Helper Functions ======

// CreateBasicDependentType creates a basic type that implements DependentType
func CreateBasicDependentType(span Span, name string) DependentType {
	return &BasicType{
		Span: span,
		Name: name,
	}
}

// IsBasicType checks if a dependent type is a basic type
func IsBasicType(dt DependentType) (*BasicType, bool) {
	bt, ok := dt.(*BasicType)
	return bt, ok
}
