package ast

import (
	"testing"

	"github.com/orizon-lang/orizon/internal/position"
)

// createSimpleSpan creates a basic position span for testing
func createSimpleSpan(line, col int) position.Span {
	return position.Span{
		Start: position.Position{Filename: "test.oriz", Line: line, Column: col},
		End:   position.Position{Filename: "test.oriz", Line: line, Column: col + 1},
	}
}

// TestBasicTransformation tests that transformations don't break basic functionality
func TestBasicTransformation(t *testing.T) {
	span := createSimpleSpan(1, 1)

	// Create a simple program
	program := &Program{
		Span:         span,
		Declarations: []Declaration{},
	}

	// Test constant folding transformer
	transformer := &ConstantFoldingTransformer{}
	result, err := transformer.Transform(program)
	if err != nil {
		t.Fatalf("Constant folding should not fail: %v", err)
	}

	if result == nil {
		t.Fatalf("Result should not be nil")
	}
}

// TestBasicValidator tests that validation works for simple cases
func TestBasicValidator(t *testing.T) {
	span := createSimpleSpan(1, 1)

	// Test valid program
	program := &Program{
		Span:         span,
		Declarations: []Declaration{},
	}

	validator := &ValidatorTransformer{}
	result, err := validator.Transform(program)
	if err != nil {
		t.Fatalf("Validation should not fail for valid program: %v", err)
	}

	if result == nil {
		t.Fatalf("Result should not be nil")
	}
}

// TestBasicPipeline tests that transformation pipelines work
func TestBasicPipeline(t *testing.T) {
	span := createSimpleSpan(1, 1)

	program := &Program{
		Span:         span,
		Declarations: []Declaration{},
	}

	pipeline := NewTransformationPipeline()
	pipeline.AddTransformer(&ConstantFoldingTransformer{})
	pipeline.AddTransformer(&ValidatorTransformer{})

	result, err := pipeline.Transform(program)
	if err != nil {
		t.Fatalf("Pipeline transformation should not fail: %v", err)
	}

	if result == nil {
		t.Fatalf("Result should not be nil")
	}
}

// TestSimpleConstantFolding tests basic constant folding
func TestSimpleConstantFolding(t *testing.T) {
	span := createSimpleSpan(1, 1)

	// Create simple addition: 2 + 3
	expr := &BinaryExpression{
		Span: span,
		Left: &Literal{
			Span:  span,
			Kind:  LiteralInteger,
			Value: int64(2),
			Raw:   "2",
		},
		Operator: OpAdd,
		Right: &Literal{
			Span:  span,
			Kind:  LiteralInteger,
			Value: int64(3),
			Raw:   "3",
		},
	}

	transformer := &ConstantFoldingTransformer{}
	result, err := transformer.Transform(expr)
	if err != nil {
		t.Fatalf("Constant folding should not fail: %v", err)
	}

	literal, ok := result.(*Literal)
	if !ok {
		t.Fatalf("Expected Literal result, got %T", result)
	}

	if literal.Value != int64(5) {
		t.Errorf("Expected 5, got %v", literal.Value)
	}
}

// TestBasicASTBuilder tests basic builder functionality
func TestBasicASTBuilder(t *testing.T) {
	builder := NewASTBuilder()

	// Test type creation
	intType := builder.Type("int")
	if intType == nil {
		t.Fatalf("Builder should create type")
	}

	basicType, ok := intType.(*BasicType)
	if !ok {
		t.Fatalf("Expected BasicType, got %T", intType)
	}

	if basicType.Kind != BasicInt {
		t.Errorf("Expected BasicInt, got %v", basicType.Kind)
	}
}
