// Real-time System and Network Programming in Orizon
// Demonstrates high-performance, low-latency programming

use std::time::{Duration, Instant};
use std::sync::atomic::{AtomicU64, Ordering};
use std::collections::VecDeque;

// Real-time memory pool allocator
struct RTMemoryPool {
    pool: *mut u8,
    block_size: usize,
    num_blocks: usize,
    free_list: atomic<*mut FreeBlock>,
    allocated_count: AtomicU64
}

struct FreeBlock {
    next: *mut FreeBlock
}

impl RTMemoryPool {
    func new(block_size: usize, num_blocks: usize) -> Result<Self, &'static str> {
        let total_size = block_size * num_blocks;
        let pool = unsafe { 
            libc::mmap(
                null_mut(),
                total_size,
                PROT_READ | PROT_WRITE,
                MAP_PRIVATE | MAP_ANONYMOUS,
                -1,
                0
            ) as *mut u8
        };
        
        if pool == MAP_FAILED {
            return Err("Failed to allocate memory pool");
        }
        
        // Initialize free list
        let mut current = pool as *mut FreeBlock;
        for i in 0..(num_blocks - 1) {
            unsafe {
                (*current).next = (pool as *mut u8).add((i + 1) * block_size) as *mut FreeBlock;
                current = (*current).next;
            }
        }
        unsafe { (*current).next = null_mut(); }
        
        Ok(RTMemoryPool {
            pool,
            block_size,
            num_blocks,
            free_list: atomic_new(pool as *mut FreeBlock),
            allocated_count: AtomicU64::new(0)
        })
    }
    
    func allocate(&self) -> Option<*mut u8> {
        loop {
            let head = atomic_load(&self.free_list);
            if head.is_null() {
                return None; // Pool exhausted
            }
            
            let next = unsafe { (*head).next };
            if atomic_compare_exchange_weak(&self.free_list, head, next) {
                self.allocated_count.fetch_add(1, Ordering::Relaxed);
                return Some(head as *mut u8);
            }
        }
    }
    
    func deallocate(&self, ptr: *mut u8) {
        if ptr.is_null() || !self.is_valid_ptr(ptr) {
            return; // Invalid pointer
        }
        
        let block = ptr as *mut FreeBlock;
        loop {
            let head = atomic_load(&self.free_list);
            unsafe { (*block).next = head; }
            
            if atomic_compare_exchange_weak(&self.free_list, head, block) {
                self.allocated_count.fetch_sub(1, Ordering::Relaxed);
                break;
            }
        }
    }
    
    func is_valid_ptr(&self, ptr: *mut u8) -> bool {
        let offset = ptr as usize - self.pool as usize;
        offset < (self.block_size * self.num_blocks) && 
        (offset % self.block_size) == 0
    }
    
    func usage_stats(&self) -> (usize, usize, f64) {
        let allocated = self.allocated_count.load(Ordering::Relaxed) as usize;
        let utilization = allocated as f64 / self.num_blocks as f64;
        (allocated, self.num_blocks, utilization)
    }
}

// Lock-free ring buffer for real-time communication
struct RTRingBuffer<T> {
    buffer: Vec<T>,
    capacity: usize,
    write_pos: AtomicU64,
    read_pos: AtomicU64
}

impl<T> RTRingBuffer<T> where T: Default + Clone {
    func new(capacity: usize) -> Self {
        let mut buffer = Vec::with_capacity(capacity);
        for _ in 0..capacity {
            buffer.push(T::default());
        }
        
        RTRingBuffer {
            buffer,
            capacity,
            write_pos: AtomicU64::new(0),
            read_pos: AtomicU64::new(0)
        }
    }
    
    func push(&self, item: T) -> Result<(), T> {
        let current_write = self.write_pos.load(Ordering::Relaxed);
        let current_read = self.read_pos.load(Ordering::Acquire);
        let next_write = (current_write + 1) % self.capacity as u64;
        
        if next_write == current_read {
            return Err(item); // Buffer full
        }
        
        unsafe {
            let ptr = self.buffer.as_ptr().add(current_write as usize) as *mut T;
            ptr::write(ptr, item);
        }
        
        self.write_pos.store(next_write, Ordering::Release);
        Ok(())
    }
    
    func pop(&self) -> Option<T> {
        let current_read = self.read_pos.load(Ordering::Relaxed);
        let current_write = self.write_pos.load(Ordering::Acquire);
        
        if current_read == current_write {
            return None; // Buffer empty
        }
        
        let item = unsafe {
            let ptr = self.buffer.as_ptr().add(current_read as usize);
            ptr::read(ptr)
        };
        
        let next_read = (current_read + 1) % self.capacity as u64;
        self.read_pos.store(next_read, Ordering::Release);
        
        Some(item)
    }
    
    func len(&self) -> usize {
        let write_pos = self.write_pos.load(Ordering::Relaxed);
        let read_pos = self.read_pos.load(Ordering::Relaxed);
        
        if write_pos >= read_pos {
            (write_pos - read_pos) as usize
        } else {
            (self.capacity as u64 - read_pos + write_pos) as usize
        }
    }
}

// High-frequency trading system simulator
struct HFTOrderBook {
    buy_orders: BTreeMap<u64, VecDeque<Order>>, // Price -> Orders
    sell_orders: BTreeMap<u64, VecDeque<Order>>,
    order_pool: RTMemoryPool,
    last_trade_price: AtomicU64,
    total_volume: AtomicU64
}

#[derive(Clone)]
struct Order {
    id: u64,
    price: u64,
    quantity: u64,
    timestamp: u64,
    side: OrderSide
}

#[derive(Clone, PartialEq)]
enum OrderSide {
    Buy,
    Sell
}

impl HFTOrderBook {
    func new() -> Result<Self, &'static str> {
        let order_pool = RTMemoryPool::new(size_of::<Order>(), 10000)?;
        
        Ok(HFTOrderBook {
            buy_orders: BTreeMap::new(),
            sell_orders: BTreeMap::new(),
            order_pool,
            last_trade_price: AtomicU64::new(0),
            total_volume: AtomicU64::new(0)
        })
    }
    
    func add_order(&mut self, mut order: Order) -> Vec<Trade> {
        let start_time = rdtsc(); // Read time stamp counter for nanosecond precision
        let mut trades = Vec::new();
        
        order.timestamp = start_time;
        
        match order.side {
            OrderSide::Buy => {
                // Match against sell orders
                while order.quantity > 0 {
                    if let Some((&price, orders)) = self.sell_orders.iter_mut().next() {
                        if price <= order.price {
                            if let Some(mut sell_order) = orders.pop_front() {
                                let trade_quantity = min(order.quantity, sell_order.quantity);
                                let trade_price = sell_order.price;
                                
                                trades.push(Trade {
                                    price: trade_price,
                                    quantity: trade_quantity,
                                    buy_order_id: order.id,
                                    sell_order_id: sell_order.id,
                                    timestamp: rdtsc()
                                });
                                
                                order.quantity -= trade_quantity;
                                sell_order.quantity -= trade_quantity;
                                
                                if sell_order.quantity > 0 {
                                    orders.push_front(sell_order);
                                }
                                
                                if orders.is_empty() {
                                    self.sell_orders.remove(&price);
                                }
                                
                                self.last_trade_price.store(trade_price, Ordering::Relaxed);
                                self.total_volume.fetch_add(trade_quantity, Ordering::Relaxed);
                            } else {
                                self.sell_orders.remove(&price);
                            }
                        } else {
                            break; // No more matching orders
                        }
                    } else {
                        break; // No sell orders
                    }
                }
                
                // Add remaining quantity to buy orders
                if order.quantity > 0 {
                    self.buy_orders.entry(order.price)
                        .or_insert_with(VecDeque::new)
                        .push_back(order);
                }
            }
            OrderSide::Sell => {
                // Similar logic for sell orders
                while order.quantity > 0 {
                    if let Some((&price, orders)) = self.buy_orders.iter_mut().rev().next() {
                        if price >= order.price {
                            if let Some(mut buy_order) = orders.pop_front() {
                                let trade_quantity = min(order.quantity, buy_order.quantity);
                                let trade_price = buy_order.price;
                                
                                trades.push(Trade {
                                    price: trade_price,
                                    quantity: trade_quantity,
                                    buy_order_id: buy_order.id,
                                    sell_order_id: order.id,
                                    timestamp: rdtsc()
                                });
                                
                                order.quantity -= trade_quantity;
                                buy_order.quantity -= trade_quantity;
                                
                                if buy_order.quantity > 0 {
                                    orders.push_front(buy_order);
                                }
                                
                                if orders.is_empty() {
                                    self.buy_orders.remove(&price);
                                }
                                
                                self.last_trade_price.store(trade_price, Ordering::Relaxed);
                                self.total_volume.fetch_add(trade_quantity, Ordering::Relaxed);
                            } else {
                                self.buy_orders.remove(&price);
                            }
                        } else {
                            break;
                        }
                    } else {
                        break;
                    }
                }
                
                if order.quantity > 0 {
                    self.sell_orders.entry(order.price)
                        .or_insert_with(VecDeque::new)
                        .push_back(order);
                }
            }
        }
        
        trades
    }
    
    func get_best_bid(&self) -> Option<u64> {
        self.buy_orders.keys().rev().next().copied()
    }
    
    func get_best_ask(&self) -> Option<u64> {
        self.sell_orders.keys().next().copied()
    }
    
    func get_spread(&self) -> Option<u64> {
        match (self.get_best_bid(), self.get_best_ask()) {
            (Some(bid), Some(ask)) => Some(ask - bid),
            _ => None
        }
    }
}

#[derive(Debug)]
struct Trade {
    price: u64,
    quantity: u64,
    buy_order_id: u64,
    sell_order_id: u64,
    timestamp: u64
}

// Network packet processing system
struct PacketProcessor {
    rx_ring: RTRingBuffer<Packet>,
    tx_ring: RTRingBuffer<Packet>,
    packet_pool: RTMemoryPool,
    stats: PacketStats
}

#[derive(Clone, Default)]
struct Packet {
    data: [u8; 1500], // MTU size
    len: usize,
    timestamp: u64,
    src_ip: u32,
    dst_ip: u32,
    protocol: u8
}

struct PacketStats {
    packets_received: AtomicU64,
    packets_sent: AtomicU64,
    bytes_received: AtomicU64,
    bytes_sent: AtomicU64,
    drops: AtomicU64
}

impl PacketProcessor {
    func new() -> Result<Self, &'static str> {
        let rx_ring = RTRingBuffer::new(8192);
        let tx_ring = RTRingBuffer::new(8192);
        let packet_pool = RTMemoryPool::new(size_of::<Packet>(), 16384)?;
        
        Ok(PacketProcessor {
            rx_ring,
            tx_ring,
            packet_pool,
            stats: PacketStats {
                packets_received: AtomicU64::new(0),
                packets_sent: AtomicU64::new(0),
                bytes_received: AtomicU64::new(0),
                bytes_sent: AtomicU64::new(0),
                drops: AtomicU64::new(0)
            }
        })
    }
    
    func receive_packet(&self, packet: Packet) -> Result<(), ()> {
        match self.rx_ring.push(packet.clone()) {
            Ok(()) => {
                self.stats.packets_received.fetch_add(1, Ordering::Relaxed);
                self.stats.bytes_received.fetch_add(packet.len as u64, Ordering::Relaxed);
                Ok(())
            }
            Err(_) => {
                self.stats.drops.fetch_add(1, Ordering::Relaxed);
                Err(())
            }
        }
    }
    
    func process_packets(&self) -> usize {
        let mut processed = 0;
        
        while let Some(mut packet) = self.rx_ring.pop() {
            // Process packet (simple firewall example)
            if self.should_forward(&packet) {
                packet.timestamp = rdtsc();
                
                if self.tx_ring.push(packet.clone()).is_ok() {
                    self.stats.packets_sent.fetch_add(1, Ordering::Relaxed);
                    self.stats.bytes_sent.fetch_add(packet.len as u64, Ordering::Relaxed);
                } else {
                    self.stats.drops.fetch_add(1, Ordering::Relaxed);
                }
            }
            
            processed += 1;
        }
        
        processed
    }
    
    func should_forward(&self, packet: &Packet) -> bool {
        // Simple firewall rules
        match packet.protocol {
            6 => true,  // TCP
            17 => true, // UDP
            1 => false, // ICMP - block
            _ => false  // Unknown protocol
        }
    }
    
    func get_stats(&self) -> (u64, u64, u64, u64, u64) {
        (
            self.stats.packets_received.load(Ordering::Relaxed),
            self.stats.packets_sent.load(Ordering::Relaxed),
            self.stats.bytes_received.load(Ordering::Relaxed),
            self.stats.bytes_sent.load(Ordering::Relaxed),
            self.stats.drops.load(Ordering::Relaxed)
        )
    }
}

// Real-time performance monitoring
struct RTProfiler {
    samples: Vec<AtomicU64>,
    current_index: AtomicU64,
    max_samples: usize
}

impl RTProfiler {
    func new(max_samples: usize) -> Self {
        let mut samples = Vec::with_capacity(max_samples);
        for _ in 0..max_samples {
            samples.push(AtomicU64::new(0));
        }
        
        RTProfiler {
            samples,
            current_index: AtomicU64::new(0),
            max_samples
        }
    }
    
    func record_latency(&self, latency_ns: u64) {
        let index = self.current_index.fetch_add(1, Ordering::Relaxed) % self.max_samples as u64;
        self.samples[index as usize].store(latency_ns, Ordering::Relaxed);
    }
    
    func get_percentile(&self, percentile: f64) -> u64 {
        let mut values: Vec<u64> = self.samples.iter()
            .map(|x| x.load(Ordering::Relaxed))
            .filter(|&x| x > 0)
            .collect();
        
        if values.is_empty() {
            return 0;
        }
        
        values.sort_unstable();
        let index = ((values.len() as f64 * percentile / 100.0) as usize).min(values.len() - 1);
        values[index]
    }
    
    func get_stats(&self) -> LatencyStats {
        let values: Vec<u64> = self.samples.iter()
            .map(|x| x.load(Ordering::Relaxed))
            .filter(|&x| x > 0)
            .collect();
        
        if values.is_empty() {
            return LatencyStats::default();
        }
        
        let sum: u64 = values.iter().sum();
        let count = values.len() as u64;
        let mean = sum / count;
        
        let variance: u64 = values.iter()
            .map(|&x| {
                let diff = if x > mean { x - mean } else { mean - x };
                diff * diff
            })
            .sum::<u64>() / count;
        
        let mut sorted_values = values;
        sorted_values.sort_unstable();
        
        LatencyStats {
            min: sorted_values[0],
            max: sorted_values[sorted_values.len() - 1],
            mean,
            stddev: (variance as f64).sqrt() as u64,
            p50: sorted_values[sorted_values.len() / 2],
            p95: sorted_values[(sorted_values.len() as f64 * 0.95) as usize],
            p99: sorted_values[(sorted_values.len() as f64 * 0.99) as usize],
            count
        }
    }
}

#[derive(Default)]
struct LatencyStats {
    min: u64,
    max: u64,
    mean: u64,
    stddev: u64,
    p50: u64,
    p95: u64,
    p99: u64,
    count: u64
}

// Inline assembly for CPU cycle counting
#[inline(always)]
unsafe func rdtsc() -> u64 {
    asm!("rdtsc", out("rax") low, out("rdx") high, options(nomem, nostack));
    ((high as u64) << 32) | (low as u64)
}

// Main demonstration
func main() -> Result<(), Box<dyn std::error::Error>> {
    println!("=== Real-Time Systems Programming Demo ===");
    
    // Memory pool demonstration
    println!("\n1. Real-Time Memory Pool:");
    let pool = RTMemoryPool::new(64, 1000)?;
    
    let start = Instant::now();
    let mut ptrs = Vec::new();
    
    for _ in 0..500 {
        if let Some(ptr) = pool.allocate() {
            ptrs.push(ptr);
        }
    }
    
    let alloc_time = start.elapsed();
    let (allocated, total, util) = pool.usage_stats();
    
    println!("Allocated {} blocks in {:?}", ptrs.len(), alloc_time);
    println!("Pool utilization: {:.1}% ({}/{})", util * 100.0, allocated, total);
    
    for ptr in ptrs {
        pool.deallocate(ptr);
    }
    
    // Ring buffer demonstration
    println!("\n2. Lock-Free Ring Buffer:");
    let ring_buffer = RTRingBuffer::new(1024);
    
    let producer = spawn_thread({
        let buffer = &ring_buffer;
        move || {
            for i in 0..10000 {
                while buffer.push(i).is_err() {
                    yield_now();
                }
            }
        }
    });
    
    let consumer = spawn_thread({
        let buffer = &ring_buffer;
        move || {
            let mut count = 0;
            while count < 10000 {
                if buffer.pop().is_some() {
                    count += 1;
                }
            }
            count
        }
    });
    
    producer.join().unwrap();
    let consumed = consumer.join().unwrap();
    println!("Produced and consumed {} items", consumed);
    
    // HFT order book demonstration
    println!("\n3. High-Frequency Trading Order Book:");
    let mut order_book = HFTOrderBook::new()?;
    let profiler = RTProfiler::new(10000);
    
    for i in 0..1000 {
        let start_time = unsafe { rdtsc() };
        
        let order = Order {
            id: i,
            price: 10000 + (i % 100),
            quantity: 100,
            timestamp: 0,
            side: if i % 2 == 0 { OrderSide::Buy } else { OrderSide::Sell }
        };
        
        let trades = order_book.add_order(order);
        let end_time = unsafe { rdtsc() };
        
        profiler.record_latency(end_time - start_time);
        
        if !trades.is_empty() {
            println!("Order {} executed {} trades", i, trades.len());
        }
    }
    
    let stats = profiler.get_stats();
    println!("Order processing latency (CPU cycles):");
    println!("  Mean: {}, P95: {}, P99: {}", stats.mean, stats.p95, stats.p99);
    
    if let Some(spread) = order_book.get_spread() {
        println!("Current spread: {} ({})", spread, spread as f64 / 100.0);
    }
    
    // Packet processor demonstration
    println!("\n4. Network Packet Processing:");
    let processor = PacketProcessor::new()?;
    
    // Simulate packet reception
    for i in 0..10000 {
        let packet = Packet {
            data: [0; 1500],
            len: 64 + (i % 1436),
            timestamp: unsafe { rdtsc() },
            src_ip: 0xC0A80001, // 192.168.0.1
            dst_ip: 0xC0A80002,  // 192.168.0.2
            protocol: if i % 3 == 0 { 6 } else { 17 } // TCP or UDP
        };
        
        processor.receive_packet(packet).ok();
    }
    
    let processed = processor.process_packets();
    let (rx_packets, tx_packets, rx_bytes, tx_bytes, drops) = processor.get_stats();
    
    println!("Processed {} packets", processed);
    println!("RX: {} packets, {} bytes", rx_packets, rx_bytes);
    println!("TX: {} packets, {} bytes", tx_packets, tx_bytes);
    println!("Drops: {}", drops);
    
    println!("\n=== Real-Time Demo Complete ===");
    Ok(())
}
