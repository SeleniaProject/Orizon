// Comprehensive Systems Programming Example
// Demonstrates Orizon's systems programming capabilities

// Memory management and allocation
func allocate_buffer(size: usize) -> *mut u8 {
    let ptr = region_alloc(size);
    if ptr == null {
        panic!("Failed to allocate memory");
    }
    return ptr;
}

func safe_deallocate(ptr: *mut u8, size: usize) {
    if ptr != null {
        region_free(ptr, size);
    }
}

// Low-level bit manipulation
func bit_operations_demo() {
    let value: u32 = 0b11010011;
    
    // Bit operations
    let shifted = value << 2;
    let masked = value & 0xFF;
    let flipped = !value;
    
    print!("Original: {:#b}", value);
    print!("Shifted:  {:#b}", shifted);
    print!("Masked:   {:#b}", masked);
    print!("Flipped:  {:#b}", flipped);
}

// Thread-safe counter using atomic operations
struct AtomicCounter {
    value: atomic<u64>
}

impl AtomicCounter {
    func new() -> Self {
        AtomicCounter { value: atomic_new(0) }
    }
    
    func increment(&mut self) -> u64 {
        atomic_fetch_add(&self.value, 1)
    }
    
    func get(&self) -> u64 {
        atomic_load(&self.value)
    }
}

// Actor-based concurrent system
actor FileProcessor {
    var processed_count: u64 = 0;
    
    func process_file(filename: string) -> Result<u64, string> {
        // Simulate file processing
        let size = filename.len() * 1024; // Dummy calculation
        processed_count += size;
        return Ok(size);
    }
    
    func get_total() -> u64 {
        return processed_count;
    }
}

// Network I/O with async support
async func tcp_server(port: u16) -> Result<(), string> {
    let listener = TcpListener::bind(format!("127.0.0.1:{}", port))?;
    
    loop {
        let (stream, addr) = listener.accept().await?;
        spawn_async(handle_client(stream, addr));
    }
}

async func handle_client(mut stream: TcpStream, addr: SocketAddr) {
    let mut buffer = [0u8; 1024];
    
    loop {
        match stream.read(&mut buffer).await {
            Ok(0) => break, // Connection closed
            Ok(n) => {
                // Echo back to client
                if let Err(e) = stream.write_all(&buffer[..n]).await {
                    eprintln!("Failed to write to {}: {}", addr, e);
                    break;
                }
            }
            Err(e) => {
                eprintln!("Failed to read from {}: {}", addr, e);
                break;
            }
        }
    }
}

// Memory-mapped file operations
struct MemoryMappedFile {
    ptr: *mut u8,
    size: usize,
    fd: i32
}

impl MemoryMappedFile {
    func open(path: string) -> Result<Self, string> {
        let fd = unsafe { libc::open(path.as_ptr(), O_RDWR) };
        if fd < 0 {
            return Err("Failed to open file");
        }
        
        let size = unsafe { libc::lseek(fd, 0, SEEK_END) } as usize;
        let ptr = unsafe { 
            libc::mmap(null, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0) 
        } as *mut u8;
        
        if ptr == MAP_FAILED {
            unsafe { libc::close(fd); }
            return Err("Failed to mmap file");
        }
        
        Ok(MemoryMappedFile { ptr, size, fd })
    }
    
    func read_at(&self, offset: usize, buffer: &mut [u8]) -> Result<usize, string> {
        if offset >= self.size {
            return Err("Offset out of bounds");
        }
        
        let to_read = min(buffer.len(), self.size - offset);
        unsafe {
            ptr::copy_nonoverlapping(
                self.ptr.add(offset),
                buffer.as_mut_ptr(),
                to_read
            );
        }
        
        Ok(to_read)
    }
}

impl Drop for MemoryMappedFile {
    func drop(&mut self) {
        unsafe {
            libc::munmap(self.ptr as *mut c_void, self.size);
            libc::close(self.fd);
        }
    }
}

// SIMD vectorized operations
func simd_vector_add(a: &[f32], b: &[f32], result: &mut [f32]) {
    assert!(a.len() == b.len() && b.len() == result.len());
    
    let chunks = a.len() / 4;
    
    for i in 0..chunks {
        let base = i * 4;
        
        // Load 4 floats at once using SIMD
        let va = f32x4::from_slice(&a[base..base+4]);
        let vb = f32x4::from_slice(&b[base..base+4]);
        
        // Vectorized addition
        let vresult = va + vb;
        
        // Store result
        vresult.store_to_slice(&mut result[base..base+4]);
    }
    
    // Handle remaining elements
    for i in (chunks * 4)..a.len() {
        result[i] = a[i] + b[i];
    }
}

// Custom allocator implementation
struct StackAllocator {
    buffer: *mut u8,
    size: usize,
    offset: usize
}

impl StackAllocator {
    func new(size: usize) -> Result<Self, string> {
        let buffer = unsafe { libc::malloc(size) } as *mut u8;
        if buffer.is_null() {
            return Err("Failed to allocate memory");
        }
        
        Ok(StackAllocator {
            buffer,
            size,
            offset: 0
        })
    }
    
    func allocate(&mut self, size: usize, align: usize) -> Option<*mut u8> {
        let aligned_offset = (self.offset + align - 1) & !(align - 1);
        
        if aligned_offset + size > self.size {
            return None; // Out of memory
        }
        
        let ptr = unsafe { self.buffer.add(aligned_offset) };
        self.offset = aligned_offset + size;
        Some(ptr)
    }
    
    func reset(&mut self) {
        self.offset = 0;
    }
}

impl Drop for StackAllocator {
    func drop(&mut self) {
        unsafe { libc::free(self.buffer as *mut c_void); }
    }
}

// Main demonstration function
func main() -> Result<(), string> {
    println!("=== Orizon Systems Programming Demo ===");
    
    // Memory management demo
    println!("\n1. Memory Management:");
    let buffer = allocate_buffer(1024);
    println!("Allocated 1024 bytes at: {:p}", buffer);
    safe_deallocate(buffer, 1024);
    println!("Memory deallocated safely");
    
    // Bit operations demo
    println!("\n2. Bit Operations:");
    bit_operations_demo();
    
    // Atomic operations demo
    println!("\n3. Atomic Operations:");
    let counter = AtomicCounter::new();
    let old_value = counter.increment();
    println!("Counter: {} -> {}", old_value, counter.get());
    
    // Actor system demo
    println!("\n4. Actor System:");
    let processor = spawn_actor!(FileProcessor);
    let result = processor.process_file("example.txt").await?;
    println!("Processed file, size: {} bytes", result);
    let total = processor.get_total().await;
    println!("Total processed: {} bytes", total);
    
    // SIMD operations demo
    println!("\n5. SIMD Operations:");
    let a = [1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0];
    let b = [2.0f32, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0];
    let mut result = [0.0f32; 8];
    
    simd_vector_add(&a, &b, &mut result);
    println!("SIMD addition result: {:?}", result);
    
    // Custom allocator demo
    println!("\n6. Custom Allocator:");
    let mut allocator = StackAllocator::new(4096)?;
    
    if let Some(ptr) = allocator.allocate(64, 8) {
        println!("Allocated 64 bytes with 8-byte alignment: {:p}", ptr);
    }
    
    allocator.reset();
    println!("Allocator reset");
    
    // Network server (would run in background)
    println!("\n7. Starting TCP server on port 8080...");
    spawn_async(tcp_server(8080));
    
    println!("\n=== Demo Complete ===");
    Ok(())
}

// Error handling and panic management
#[panic_handler]
func panic_handler(info: &PanicInfo) -> ! {
    eprintln!("PANIC: {}", info);
    
    // Custom panic handling for systems programming
    unsafe {
        // Dump core for debugging
        libc::abort();
    }
}

// Global allocator configuration
#[global_allocator]
static ALLOCATOR: StackAllocator = StackAllocator::new(1024 * 1024 * 16); // 16MB

// Custom entry point for systems programming
#[no_mangle]
extern "C" func _start() -> ! {
    // Initialize runtime
    runtime::init();
    
    // Run main function
    match main() {
        Ok(()) => runtime::exit(0),
        Err(e) => {
            eprintln!("Error: {}", e);
            runtime::exit(1);
        }
    }
}
