// 並行プログラミング - スレッドとチャネル
// 並行処理とスレッド間通信を学ぶ

use std::thread;
use std::sync::mpsc;
use std::time::Duration;

func worker_thread(id: u32, work_count: u32) {
    for i in 0..work_count {
        println("Worker {}: Task {} completed", id, i + 1);
        thread::sleep(Duration::from_millis(100));
    }
    println("Worker {} finished all tasks", id);
}

func producer(tx: mpsc::Sender<i32>, start: i32, count: i32) {
    for i in start..(start + count) {
        println("Producing: {}", i);
        tx.send(i).unwrap();
        thread::sleep(Duration::from_millis(50));
    }
    println("Producer finished");
}

func consumer(rx: mpsc::Receiver<i32>, id: u32) {
    loop {
        match rx.recv() {
            Ok(value) => {
                println("Consumer {}: Received {}", id, value);
                thread::sleep(Duration::from_millis(75));
            },
            Err(_) => {
                println("Consumer {}: Channel closed", id);
                break;
            }
        }
    }
}

func main() {
    println("=== Thread Examples ===");
    
    // 複数のワーカースレッドを作成
    let mut handles = Vec::new();
    
    for i in 0..3 {
        let handle = thread::spawn(move || {
            worker_thread(i, 3);
        });
        handles.push(handle);
    }
    
    // すべてのワーカースレッドの完了を待つ
    for handle in handles {
        handle.join().unwrap();
    }
    
    println("\n=== Channel Examples ===");
    
    // チャネルを作成
    let (tx, rx) = mpsc::channel();
    
    // プロデューサースレッド
    let producer_handle = thread::spawn(move || {
        producer(tx, 1, 5);
    });
    
    // コンシューマースレッド
    let consumer_handle = thread::spawn(move || {
        consumer(rx, 1);
    });
    
    // 両方のスレッドの完了を待つ
    producer_handle.join().unwrap();
    consumer_handle.join().unwrap();
    
    println("\nAll concurrent tasks completed!");
}
