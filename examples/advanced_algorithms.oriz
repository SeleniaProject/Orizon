// Advanced Data Structures and Algorithms in Orizon
// Demonstrates sophisticated programming constructs

// Generic Binary Search Tree with dependent types
struct BST<T> where T: Ord + Clone {
    root: Option<Box<Node<T>>>
}

struct Node<T> {
    value: T,
    left: Option<Box<Node<T>>>,
    right: Option<Box<Node<T>>>,
    height: usize
}

impl<T> BST<T> where T: Ord + Clone {
    func new() -> Self {
        BST { root: None }
    }
    
    func insert(&mut self, value: T) {
        self.root = Self::insert_node(self.root.take(), value);
    }
    
    func insert_node(node: Option<Box<Node<T>>>, value: T) -> Option<Box<Node<T>>> {
        match node {
            None => Some(Box::new(Node {
                value,
                left: None,
                right: None,
                height: 1
            })),
            Some(mut n) => {
                if value < n.value {
                    n.left = Self::insert_node(n.left.take(), value);
                } else if value > n.value {
                    n.right = Self::insert_node(n.right.take(), value);
                } else {
                    return Some(n); // Duplicate value
                }
                
                // Update height and rebalance
                n.height = 1 + max(
                    Self::height(&n.left),
                    Self::height(&n.right)
                );
                
                Some(Self::rebalance(n))
            }
        }
    }
    
    func rebalance(mut node: Box<Node<T>>) -> Box<Node<T>> {
        let balance = Self::balance_factor(&node);
        
        if balance > 1 {
            // Left heavy
            if Self::balance_factor(&node.left) < 0 {
                node.left = Some(Self::rotate_left(node.left.take().unwrap()));
            }
            return Self::rotate_right(node);
        }
        
        if balance < -1 {
            // Right heavy
            if Self::balance_factor(&node.right) > 0 {
                node.right = Some(Self::rotate_right(node.right.take().unwrap()));
            }
            return Self::rotate_left(node);
        }
        
        node
    }
    
    func search(&self, value: &T) -> bool {
        Self::search_node(&self.root, value)
    }
    
    func search_node(node: &Option<Box<Node<T>>>, value: &T) -> bool {
        match node {
            None => false,
            Some(n) => {
                if value == &n.value {
                    true
                } else if value < &n.value {
                    Self::search_node(&n.left, value)
                } else {
                    Self::search_node(&n.right, value)
                }
            }
        }
    }
}

// Lock-free stack using atomic operations
struct LockFreeStack<T> {
    head: atomic<*mut Node<T>>
}

impl<T> LockFreeStack<T> {
    func new() -> Self {
        LockFreeStack {
            head: atomic_new(null_mut())
        }
    }
    
    func push(&self, value: T) {
        let new_node = Box::into_raw(Box::new(Node {
            value,
            next: null_mut()
        }));
        
        loop {
            let current_head = atomic_load(&self.head);
            unsafe { (*new_node).next = current_head; }
            
            if atomic_compare_exchange_weak(
                &self.head,
                current_head,
                new_node
            ) {
                break;
            }
        }
    }
    
    func pop(&self) -> Option<T> {
        loop {
            let current_head = atomic_load(&self.head);
            if current_head.is_null() {
                return None;
            }
            
            let next = unsafe { (*current_head).next };
            
            if atomic_compare_exchange_weak(
                &self.head,
                current_head,
                next
            ) {
                let value = unsafe { Box::from_raw(current_head).value };
                return Some(value);
            }
        }
    }
}

// Hash table with Robin Hood hashing
struct RobinHoodHashMap<K, V> where K: Hash + Eq {
    buckets: Vec<Option<Entry<K, V>>>,
    size: usize,
    capacity: usize,
    load_factor: f64
}

struct Entry<K, V> {
    key: K,
    value: V,
    psl: usize // Probe sequence length
}

impl<K, V> RobinHoodHashMap<K, V> where K: Hash + Eq + Clone, V: Clone {
    func new() -> Self {
        let initial_capacity = 16;
        RobinHoodHashMap {
            buckets: vec![None; initial_capacity],
            size: 0,
            capacity: initial_capacity,
            load_factor: 0.75
        }
    }
    
    func insert(&mut self, key: K, value: V) -> Option<V> {
        if self.size as f64 / self.capacity as f64 > self.load_factor {
            self.resize();
        }
        
        let hash = self.hash(&key);
        let mut index = hash % self.capacity;
        let mut psl = 0;
        let mut entry = Entry { key, value, psl };
        
        loop {
            match &mut self.buckets[index] {
                None => {
                    self.buckets[index] = Some(entry);
                    self.size += 1;
                    return None;
                }
                Some(existing) => {
                    if existing.key == entry.key {
                        let old_value = existing.value.clone();
                        existing.value = entry.value;
                        return Some(old_value);
                    }
                    
                    if psl > existing.psl {
                        // Robin Hood: steal from the rich
                        let mut temp = entry;
                        entry = existing.clone();
                        *existing = temp;
                    }
                }
            }
            
            index = (index + 1) % self.capacity;
            psl += 1;
            entry.psl = psl;
        }
    }
    
    func get(&self, key: &K) -> Option<&V> {
        let hash = self.hash(key);
        let mut index = hash % self.capacity;
        let mut psl = 0;
        
        loop {
            match &self.buckets[index] {
                None => return None,
                Some(entry) => {
                    if entry.key == *key {
                        return Some(&entry.value);
                    }
                    
                    if psl > entry.psl {
                        return None; // Would have been found by now
                    }
                }
            }
            
            index = (index + 1) % self.capacity;
            psl += 1;
        }
    }
}

// B+ Tree for database-like operations
struct BPlusTree<K, V> where K: Ord + Clone {
    root: Box<Node<K, V>>,
    order: usize
}

enum Node<K, V> {
    Internal {
        keys: Vec<K>,
        children: Vec<Box<Node<K, V>>>
    },
    Leaf {
        entries: Vec<(K, V)>,
        next: Option<Box<Node<K, V>>>
    }
}

impl<K, V> BPlusTree<K, V> where K: Ord + Clone, V: Clone {
    func new(order: usize) -> Self {
        BPlusTree {
            root: Box::new(Node::Leaf {
                entries: Vec::new(),
                next: None
            }),
            order
        }
    }
    
    func insert(&mut self, key: K, value: V) {
        if self.is_full(&self.root) {
            let old_root = mem::replace(&mut self.root, 
                Box::new(Node::Internal { 
                    keys: Vec::new(), 
                    children: Vec::new() 
                })
            );
            
            self.split_child(&mut self.root, 0, old_root);
        }
        
        self.insert_non_full(&mut self.root, key, value);
    }
    
    func search(&self, key: &K) -> Option<&V> {
        self.search_node(&self.root, key)
    }
    
    func range_query(&self, start: &K, end: &K) -> Vec<(K, V)> {
        let mut result = Vec::new();
        self.range_query_node(&self.root, start, end, &mut result);
        result
    }
}

// Parallel merge sort using work-stealing
func parallel_merge_sort<T>(mut arr: Vec<T>) -> Vec<T> 
where T: Ord + Clone + Send + Sync + 'static {
    let len = arr.len();
    if len <= 1 {
        return arr;
    }
    
    if len < 1000 {
        // Use sequential sort for small arrays
        arr.sort();
        return arr;
    }
    
    let mid = len / 2;
    let (left, right) = arr.split_at_mut(mid);
    
    // Spawn parallel tasks
    let left_handle = spawn_task(move || {
        parallel_merge_sort(left.to_vec())
    });
    
    let right_handle = spawn_task(move || {
        parallel_merge_sort(right.to_vec())
    });
    
    // Wait for completion and merge
    let left_sorted = left_handle.await;
    let right_sorted = right_handle.await;
    
    merge(left_sorted, right_sorted)
}

func merge<T>(left: Vec<T>, right: Vec<T>) -> Vec<T> where T: Ord {
    let mut result = Vec::with_capacity(left.len() + right.len());
    let mut left_iter = left.into_iter();
    let mut right_iter = right.into_iter();
    let mut left_peek = left_iter.next();
    let mut right_peek = right_iter.next();
    
    loop {
        match (left_peek.as_ref(), right_peek.as_ref()) {
            (Some(l), Some(r)) => {
                if l <= r {
                    result.push(left_peek.take().unwrap());
                    left_peek = left_iter.next();
                } else {
                    result.push(right_peek.take().unwrap());
                    right_peek = right_iter.next();
                }
            }
            (Some(_), None) => {
                result.push(left_peek.take().unwrap());
                result.extend(left_iter);
                break;
            }
            (None, Some(_)) => {
                result.push(right_peek.take().unwrap());
                result.extend(right_iter);
                break;
            }
            (None, None) => break,
        }
    }
    
    result
}

// Graph algorithms with generic vertex types
struct Graph<V, E> where V: Hash + Eq + Clone {
    vertices: HashSet<V>,
    edges: HashMap<V, HashMap<V, E>>
}

impl<V, E> Graph<V, E> where V: Hash + Eq + Clone, E: Clone {
    func new() -> Self {
        Graph {
            vertices: HashSet::new(),
            edges: HashMap::new()
        }
    }
    
    func add_vertex(&mut self, vertex: V) {
        self.vertices.insert(vertex.clone());
        self.edges.entry(vertex).or_insert_with(HashMap::new);
    }
    
    func add_edge(&mut self, from: V, to: V, weight: E) {
        self.add_vertex(from.clone());
        self.add_vertex(to.clone());
        self.edges.get_mut(&from).unwrap().insert(to, weight);
    }
    
    func dijkstra(&self, start: &V) -> HashMap<V, E> 
    where E: Add<Output = E> + Ord + Copy + Default {
        let mut distances: HashMap<V, E> = HashMap::new();
        let mut visited: HashSet<V> = HashSet::new();
        let mut priority_queue = BinaryHeap::new();
        
        distances.insert(start.clone(), E::default());
        priority_queue.push((Reverse(E::default()), start.clone()));
        
        while let Some((Reverse(current_dist), current_vertex)) = priority_queue.pop() {
            if visited.contains(&current_vertex) {
                continue;
            }
            
            visited.insert(current_vertex.clone());
            
            if let Some(neighbors) = self.edges.get(&current_vertex) {
                for (neighbor, &edge_weight) in neighbors {
                    if !visited.contains(neighbor) {
                        let new_dist = current_dist + edge_weight;
                        let is_shorter = distances.get(neighbor)
                            .map_or(true, |&old_dist| new_dist < old_dist);
                        
                        if is_shorter {
                            distances.insert(neighbor.clone(), new_dist);
                            priority_queue.push((Reverse(new_dist), neighbor.clone()));
                        }
                    }
                }
            }
        }
        
        distances
    }
}

// Demonstration function
func main() {
    println!("=== Advanced Data Structures Demo ===");
    
    // BST demonstration
    println!("\n1. Balanced Binary Search Tree:");
    let mut bst = BST::new();
    let values = [5, 3, 7, 2, 4, 6, 8, 1, 9];
    
    for value in values {
        bst.insert(value);
    }
    
    println!("Inserted values: {:?}", values);
    println!("Search for 4: {}", bst.search(&4));
    println!("Search for 10: {}", bst.search(&10));
    
    // Lock-free stack demonstration
    println!("\n2. Lock-free Stack:");
    let stack = LockFreeStack::new();
    
    // Simulate concurrent access
    let handles = (0..10).map(|i| {
        let stack_ref = &stack;
        spawn_thread(move || {
            stack_ref.push(i);
            stack_ref.pop()
        })
    }).collect::<Vec<_>>();
    
    for handle in handles {
        if let Some(value) = handle.join() {
            println!("Popped: {:?}", value);
        }
    }
    
    // Hash map demonstration
    println!("\n3. Robin Hood Hash Map:");
    let mut map = RobinHoodHashMap::new();
    map.insert("hello", 42);
    map.insert("world", 24);
    map.insert("rust", 84);
    
    println!("hello: {:?}", map.get(&"hello"));
    println!("world: {:?}", map.get(&"world"));
    println!("missing: {:?}", map.get(&"missing"));
    
    // B+ Tree demonstration
    println!("\n4. B+ Tree:");
    let mut btree = BPlusTree::new(4);
    
    for i in 1..=20 {
        btree.insert(i, format!("value_{}", i));
    }
    
    println!("Search for key 10: {:?}", btree.search(&10));
    let range_results = btree.range_query(&5, &15);
    println!("Range query [5, 15]: {} results", range_results.len());
    
    // Parallel sorting demonstration
    println!("\n5. Parallel Merge Sort:");
    let mut data: Vec<i32> = (0..10000).rev().collect();
    let start_time = Instant::now();
    
    let sorted = parallel_merge_sort(data);
    let duration = start_time.elapsed();
    
    println!("Sorted 10000 elements in {:?}", duration);
    println!("First 10 elements: {:?}", &sorted[..10]);
    println!("Last 10 elements: {:?}", &sorted[sorted.len()-10..]);
    
    // Graph algorithms demonstration
    println!("\n6. Graph Algorithms:");
    let mut graph = Graph::new();
    
    // Create a simple graph
    graph.add_edge("A", "B", 4);
    graph.add_edge("A", "C", 2);
    graph.add_edge("B", "C", 1);
    graph.add_edge("B", "D", 5);
    graph.add_edge("C", "D", 8);
    graph.add_edge("C", "E", 10);
    graph.add_edge("D", "E", 2);
    
    let distances = graph.dijkstra(&"A");
    println!("Shortest distances from A:");
    for (vertex, distance) in distances {
        println!("  {} -> {}: {}", "A", vertex, distance);
    }
    
    println!("\n=== Demo Complete ===");
}
